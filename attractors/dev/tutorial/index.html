<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/DynamicalSystemsDocs.jl/'</script><script charset="utf-8" src="../../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Attractors.jl Tutorial · Attractors.jl</title><meta content="Attractors.jl Tutorial · Attractors.jl" name="title"/><meta content="Attractors.jl Tutorial · Attractors.jl" property="og:title"/><meta content="Attractors.jl Tutorial · Attractors.jl" property="twitter:title"/><meta content="Documentation for Attractors.jl." name="description"/><meta content="Documentation for Attractors.jl." property="og:description"/><meta content="Documentation for Attractors.jl." property="twitter:description"/><script data-outdated-warner="" src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="catppuccin-mocha" href="../assets/themes/catppuccin-mocha.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-macchiato" href="../assets/themes/catppuccin-macchiato.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-frappe" href="../assets/themes/catppuccin-frappe.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-latte" href="../assets/themes/catppuccin-latte.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link href="nothing/DynamicalSystemsDocs.jl/attractors/stable/tutorial/" rel="canonical"/><link href="../../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><a class="nav-link nav-item" href="../../../dynamicalsystems/">DynamicalSystems.jl</a><div class="nav-dropdown"><button class="nav-item dropdown-label">Core</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../statespacesets/">StateSpaceSets.jl - numerical handling of sets in state space</a><a class="nav-link nav-item" href="../../../dynamicalsystemsbase/">DynamicalSystemsBase.jl - infrastructure for programming NLD algorithms</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">Nonlinear Dynamics</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../predefineddynamicalsystems/">PredefinedDynamicalSystems.jl - predefined dynamical systems used in publications</a><a class="nav-link nav-item" href="../../../chaostools/">ChaosTools.jl - various tools for analysing nonlinear and chaotic behaviour</a><a class="nav-link active nav-item" href="../../">Attractors.jl - find attractors and basins; continuation; tipping</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">Nonlinear Timeseries Analysis</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../delayembeddings/">DelayEmbeddings.jl - optimal (unified/separated) delay coordinate embeddings</a><a class="nav-link nav-item" href="../../../fractaldimensions/">FractalDimensions.jl - dozens of estimators for fractal dimensions</a><a class="nav-link nav-item" href="../../../complexitymeasures/">ComplexityMeasures.jl - rigorous framework for probabilities, entropies, and other complexity measures</a><a class="nav-link nav-item" href="../../../timeseriessurrogates/">TimeseriesSurrogates.jl - dozes of ways to generate timeseries surrogates and tests hypothesis</a><a class="nav-link nav-item" href="../../../recurrenceanalysis/">RecurrenceAnalysis.jl - recurrence quantification and recurrence network analysis</a></ul></div><div class="search nav-item"><input id="search-input" placeholder="Search..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Attractors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Attractors.jl</a></li><li class="is-active"><a class="tocitem" href="">Attractors.jl Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Input:-a-DynamicalSystem"><span>Input: a <code>DynamicalSystem</code></span></a></li><li><a class="tocitem" href="#Finding-attractors"><span>Finding attractors</span></a></li><li><a class="tocitem" href="#Continuation"><span>Continuation</span></a></li><li><a class="tocitem" href="#Enhancing-the-continuation"><span>Enhancing the continuation</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../examples/">Examples for Attractors.jl</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">Attractors.jl Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Attractors.jl Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Attractors.jl/blob/main/docs/src/tutorial.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" href="javascript:;" id="documenter-article-toggle-button" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial"><a class="docs-heading-anchor" href="#tutorial">Attractors.jl Tutorial</a><a id="tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial" title="Permalink"></a></h1><p><a href="../#Attractors"><code>Attractors</code></a> is a submodule of the <strong>DynamicalSystems.jl</strong> library. This tutorial will walk you through its main functionality. That is, given a <code>DynamicalSystem</code> instance, find all its attractors and their basins of attraction. Then, continue these attractors, and their stability properties, across a parameter value. It also offers various functions that compute nonlocal stability properties for an attractor, any of which can be used in the continuation to quantify stability.</p><p>Besides this main functionality, there are plenty of other stuff, like for example <a href="@ref"><code>edgestate</code></a> or <a href="../api/#Attractors.basins_fractal_dimension"><code>basins_fractal_dimension</code></a>, but we won't cover anything else in this introductory tutorial. See the <a href="@ref examples">examples</a> page instead.</p><h2 id="Input:-a-DynamicalSystem"><a class="docs-heading-anchor" href="#Input:-a-DynamicalSystem">Input: a <code>DynamicalSystem</code></a><a id="Input:-a-DynamicalSystem-1"></a><a class="docs-heading-anchor-permalink" href="#Input:-a-DynamicalSystem" title="Permalink"></a></h2><p>The key input for most functionality of Attractors.jl is an instance of a <code>DynamicalSystem</code>. If you don't know how to make a <code>DynamicalSystem</code>, you need to consult the main tutorial of the <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/dynamicalsystems/stable/tutorial/">DynamicalSystems.jl library</a>. For this tutorial we will use a modified Lorenz-like system with equations</p><p class="math-container">\[\begin{align*}
\dot{x} &amp; = y - x \\
\dot{y}  &amp;= -x*z + b*|z| \\
\dot{z}  &amp;= x*y - a \\
\end{align*}\]</p><p>which we define in code as</p><pre><code class="language-julia hljs">using Attractors
using OrdinaryDiffEq # for accessing advanced ODE Solvers

function modified_lorenz_rule(u, p, t)
    x, y, z = u; a, b = p
    dx = y - x
    dy = - x*z + b*abs(z)
    dz = x*y - a
    return SVector(dx, dy, dz)
end

p0 = [5.0, 0.1] # parameters
u0 = [-4.0, 5, 0] # state
ds = CoupledODEs(modified_lorenz_rule, u0, p0;
    diffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9, dt = 0.01)
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-dimensional CoupledODEs
 deterministic: true
 discrete time: false
 in-place:      false
 dynamic rule:  modified_lorenz_rule
 ODE solver:    Vern9
 ODE kwargs:    (abstol = 1.0e-9, reltol = 1.0e-9, dt = 0.01)
 parameters:    [5.0, 0.1]
 time:          0.0
 state:         [-4.0, 5.0, 0.0]
</code></pre><h2 id="Finding-attractors"><a class="docs-heading-anchor" href="#Finding-attractors">Finding attractors</a><a id="Finding-attractors-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-attractors" title="Permalink"></a></h2><p>There are two major methods for finding attractors in dynamical systems. Explanation of how they work is in their respective docs.</p><ol><li><a href="../api/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a>.</li><li><a href="../api/#Attractors.AttractorsViaFeaturizing"><code>AttractorsViaFeaturizing</code></a>.</li></ol><p>You can consult (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>) for a comparison between the two.</p><p>As far as the user is concerned, both algorithms are part of the same interface, and can be used in the same way. The interface is extendable as well, and works as follows.</p><p>First, we create an instance of such an "attractor finding algorithm", which we call <code>AttractorMapper</code>. For example, <a href="../api/#Attractors.AttractorsViaRecurrences"><code>AttractorsViaRecurrences</code></a> requires a tesselated grid of the state space to search for attractors in. It also allows the user to tune some meta parameters, but in our example they are already tuned for the dynamical system at hand. So we initialize</p><pre><code class="language-julia hljs">grid = (
    range(-10.0, 10.0; length = 100), # x
    range(-15.0, 15.0; length = 100), # y
    range(-15.0, 15.0; length = 100), # z
)

mapper = AttractorsViaRecurrences(ds, grid;
    consecutive_recurrences = 1000, attractor_locate_steps = 1000,
    consecutive_lost_steps = 100,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AttractorsViaRecurrences
 system:      CoupledODEs
 grid:        (-10.0:0.20202020202020202:10.0, -15.0:0.30303030303030304:15.0, -15.0:0.30303030303030304:15.0)
 attractors:  Dict{Int64, StateSpaceSet{3, Float64}}()
</code></pre><p>This <code>mapper</code> can map any initial condition <code>u</code> to the corresponding attractor ID, for example</p><pre><code class="language-julia hljs">mapper([-4.0, 5, 0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>while</p><pre><code class="language-julia hljs">mapper([4.0, 2, 0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>the fact that these two different conditions got assigned different IDs means that they converged to a different attractor. The attractors are stored in the mapper internally, to obtain them we use the function</p><pre><code class="language-julia hljs">attractors = extract_attractors(mapper)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, StateSpaceSet{3, Float64}} with 2 entries:
  2 =&gt; 3-dimensional StateSpaceSet{Float64} with 208 points
  1 =&gt; 3-dimensional StateSpaceSet{Float64} with 783 points</code></pre><p>In Attractors.jl, all information regarding attractors is always a standard Julia <code>Dict</code>, which maps attractor IDs (positive integers) to the corresponding quantity. Here the quantity are the attractors themselves, represented as <code>StateSpaceSet</code>.</p><p>Let's visualize them</p><pre><code class="language-julia hljs">using CairoMakie
fig = Figure()
ax = Axis(fig[1,1]; title = "bistable lorenz-like")
for (k, A) in attractors
    scatter!(ax, A[:, 1], A[:, 2]; label = "ID = $(k)")
end
axislegend(ax; position = :lt)
fig</code></pre><img alt="Example block output" src="e26acc73.png"/><p>In our example system we see that for the chosen parameters there are two coexisting attractors: a limit cycle and a chaotic attractor. There may be more attractors though! We've only checked two initial conditions, so we could have found at most two attractors! However, it can get tedious to manually iterate over initial conditions, which is why this <code>mapper</code> is typically given to higher level functions for finding attractors and their basins of attraction. The simplest one is <a href="../api/#Attractors.basins_fractions"><code>basins_fractions</code></a>. Using the <code>mapper</code>, it finds "all" attractors of the dynamical system and reports the state space fraction each attractors attracts. The search is probabilistic, so "all" attractors means those that at least one initial condition converged to.</p><p>We can provide explicitly initial conditions to <a href="@ref"><code>basins_fraction</code></a>, however it is typically simpler to provide it with with a state space sampler instead: a function that generates random initial conditions in the region of the state space that we are interested in. Here this region coincides with <code>grid</code>, so we can simply do:</p><pre><code class="language-julia hljs">sampler, = statespace_sampler(grid)

sampler() # random i.c.</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 -3.5255601623096062
 -4.013980458599773
  7.53517393466165</code></pre><pre><code class="language-julia hljs">sampler() # another random i.c.</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
  6.622142010014194
 -7.275505703045054
  5.971429192141937</code></pre><p>and finally call</p><pre><code class="language-julia hljs">fs = basins_fractions(mapper, sampler)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Float64} with 2 entries:
  2 =&gt; 0.314
  1 =&gt; 0.686</code></pre><p>The returned <code>fs</code> is a dictionary mapping each attractor ID to the fraction of the state space the corresponding basin occupies. With this we can confirm that there are (likely) only two attractors and that both attractors are robust as both have sufficiently large basin fractions.</p><p>To obtain the full basins, which is computationally much more expensive, use <a href="../api/#Attractors.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p>You can use alternative algorithms in <a href="../api/#Attractors.basins_fractions"><code>basins_fractions</code></a>, see the documentation of <a href="../api/#Attractors.AttractorMapper"><code>AttractorMapper</code></a> for possible subtypes. <a href="../api/#Attractors.AttractorMapper"><code>AttractorMapper</code></a> defines an extendable interface and can be enriched with other methods in the future!</p><h2 id="Continuation"><a class="docs-heading-anchor" href="#Continuation">Continuation</a><a id="Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation" title="Permalink"></a></h2><p>If you have heard before the word "continuation", then you are likely aware of the <strong>traditional continuation-based bifurcation analysis (CBA)</strong> offered by many software, such as AUTO, MatCont, and in Julia <a href="https://github.com/bifurcationkit/BifurcationKit.jl">BifurcationKit.jl</a>. Here we offer a completely different kind of continuation called <strong>attractors &amp; basins continuation</strong>.</p><p>A direct comparison of the two approaches is not truly possible, because they do different things. The traditional linearized continuation analysis continues the curves of individual fixed points across the joint state-parameter space. The attractor and basins continuation first finds all attractors at all parameter values and then <em>matches</em> appropriately similar attractors across different parameters, giving the illusion of continuing them individually.</p><p>This is a fundamental difference. With our approach, one finds all attractors (or almost all, for insufficiently dense sampling). And because all attractors are simultaneously tracked across the parameter axis, the user may arbitrarily estimate <em>any</em> property of the attractors and how it varies as the parameter varies. A more detailed comparison between these two approaches can be found in (<a href="../references/#Datseris2023">Datseris <em>et al.</em>, 2023</a>).</p><p>To perform the continuation is extremely simple. First, we decide what parameter, and what range, to continue over:</p><pre><code class="language-julia hljs">prange = 4.7:0.02:6
pidx = 1 # index of the parameter</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>Then, we may call the <a href="../api/#Attractors.continuation"><code>continuation</code></a> function. We have to provide a continuation algorithm, which itself references an <a href="../api/#Attractors.AttractorMapper"><code>AttractorMapper</code></a>. In this example we will re-use the <code>mapper</code> to create a <a href="../api/#Attractors.RecurrencesFindAndMatch"><code>RecurrencesFindAndMatch</code></a> continuation algorithm. This algorithm uses the <code>mapper</code> to find all attractors at each parameter value. Then, it performs a "matching" step, ensuring a "continuity" of the attractor label across the parameter axis. You can read the docstring for more details, as this algorithm is quite sophisticated!</p><p>For now we can use all of its default options which are reliable 99% of the time</p><pre><code class="language-julia hljs">rafm = RecurrencesFindAndMatch(mapper)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RecurrencesFindAndMatch{AttractorsViaRecurrences{CoupledODEs{false, 3, OrdinaryDiffEq.ODEIntegrator{OrdinaryDiffEq.Vern9{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, false, SVector{3, Float64}, Nothing, Float64, Vector{Float64}, Float64, Float64, Float64, Float64, Vector{SVector{3, Float64}}, SciMLBase.ODESolution{Float64, 2, Vector{SVector{3, Float64}}, Nothing, Nothing, Vector{Float64}, Vector{Vector{SVector{3, Float64}}}, SciMLBase.ODEProblem{SVector{3, Float64}, Tuple{Float64, Float64}, false, Vector{Float64}, SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.modified_lorenz_rule), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}, SciMLBase.StandardODEProblem}, OrdinaryDiffEq.Vern9{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, OrdinaryDiffEq.InterpolationData{SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.modified_lorenz_rule), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Vector{SVector{3, Float64}}, Vector{Float64}, Vector{Vector{SVector{3, Float64}}}, Nothing, OrdinaryDiffEq.Vern9ConstantCache, Nothing}, SciMLBase.DEStats, Nothing, Nothing, Nothing}, SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.modified_lorenz_rule), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, OrdinaryDiffEq.Vern9ConstantCache, OrdinaryDiffEq.DEOptions{Float64, Float64, Float64, Float64, OrdinaryDiffEq.PIController{Rational{Int64}}, typeof(DiffEqBase.ODE_DEFAULT_NORM), typeof(LinearAlgebra.opnorm), Bool, SciMLBase.CallbackSet{Tuple{}, Tuple{}}, typeof(DiffEqBase.ODE_DEFAULT_ISOUTOFDOMAIN), typeof(DiffEqBase.ODE_DEFAULT_PROG_MESSAGE), typeof(DiffEqBase.ODE_DEFAULT_UNSTABLE_CHECK), DataStructures.BinaryHeap{Float64, DataStructures.FasterForward}, DataStructures.BinaryHeap{Float64, DataStructures.FasterForward}, Nothing, Nothing, Float64, Tuple{}, Tuple{}, Tuple{}}, SVector{3, Float64}, Float64, Nothing, OrdinaryDiffEq.DefaultInit, Nothing}, Vector{Float64}}, Attractors.BasinsInfo{3, Attractors.RegularGrid{3, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, Float64, Attractors.SparseArray{Int64, 3}}, Attractors.RegularGrid{3, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Base.Pairs{Symbol, Int64, Tuple{Symbol, Symbol, Symbol}, @NamedTuple{consecutive_recurrences::Int64, attractor_locate_steps::Int64, consecutive_lost_steps::Int64}}}, Centroid{Euclidean}, Float64, typeof(Attractors._default_seeding_process), typeof(identity)}(AttractorsViaRecurrences
 system:      CoupledODEs
 grid:        (-10.0:0.20202020202020202:10.0, -15.0:0.30303030303030304:15.0, -15.0:0.30303030303030304:15.0)
 attractors:  Dict{Int64, StateSpaceSet{3, Float64}}(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 208 points, 1 =&gt; 3-dimensional StateSpaceSet{Float64} with 783 points)
, Centroid{Euclidean}(Euclidean(0.0)), Inf, false, Attractors._default_seeding_process, identity)</code></pre><p>and call</p><pre><code class="language-julia hljs">fractions_curves, attractors_info = continuation(
	rafm, prange, pidx, sampler; samples_per_parameter = 1_000
)

attractors_info</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">66-element Vector{Dict{Int64, StateSpaceSet{3, Float64}}}:
 Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 418 points)
 Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 404 points)
 Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 320 points)
 Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 348 points)
 Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 328 points)
 Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 335 points)
 Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 334 points)
 Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 319 points)
 Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 355 points)
 Dict(1 =&gt; 3-dimensional StateSpaceSet{Float64} with 326 points)
 ⋮
 Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 380 points, 3 =&gt; 3-dimensional StateSpaceSet{Float64} with 475 points)
 Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 370 points, 3 =&gt; 3-dimensional StateSpaceSet{Float64} with 400 points)
 Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 370 points, 3 =&gt; 3-dimensional StateSpaceSet{Float64} with 313 points)
 Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 370 points, 3 =&gt; 3-dimensional StateSpaceSet{Float64} with 319 points)
 Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 365 points)
 Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 335 points)
 Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 253 points)
 Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 248 points)
 Dict(2 =&gt; 3-dimensional StateSpaceSet{Float64} with 264 points)</code></pre><p>the output is given as two vectors. Each vector is a dictionary mapping attractor IDs to their fractions, or their state space sets, respectively. Both vectors have the same size as the parameter range. For example, the attractors at the 34-th parameter value are:</p><pre><code class="language-julia hljs">attractors_info[34]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, StateSpaceSet{3, Float64}} with 2 entries:
  2 =&gt; 3-dimensional StateSpaceSet{Float64} with 510 points
  1 =&gt; 3-dimensional StateSpaceSet{Float64} with 221 points</code></pre><p>There is a fantastic convenience function for animating the attractors evolution, that utilizes things we have already defined:</p><pre><code class="language-julia hljs">animate_attractors_continuation(
    ds, attractors_info, fractions_curves, prange, pidx;
);</code></pre><video autoplay="" controls="" loop="" width="auto"><source src="../attracont.mp4" type="video/mp4"/></video><p>Hah, how cool is that! The attractors pop in and out of existence like out of nowhere! It would be incredibly difficult to find these attractors in traditional continuation software where a rough estimate of the period is required! (It would also be too hard due to the presence of chaos for most of the parameter values, but that's another issue!)</p><p>Now typically a continuation is visualized in a 2D plot where the x axis is the parameter axis. We can do this with the convenience function:</p><pre><code class="language-julia hljs">fig = plot_basins_attractors_curves(
	fractions_curves, attractors_info, A -&gt; minimum(A[:, 1]), prange,
)</code></pre><img alt="Example block output" src="92b377f6.png"/><p>In the top panel are the basin fractions, by default plotted as stacked bars. Bottom panel is a visualization of the tracked attractors. The argument <code>A -&gt; minimum(A[:, 1])</code> is simply a function that maps an attractor into a real number for plotting. We can provide more functions to visualize other aspects of the attractors:</p><pre><code class="language-julia hljs">using Statistics: std

a2rs = [
    A -&gt; minimum(A[:, 1]),
    A -&gt; log(length(A)), # proxy for "complexity"
]

fig = plot_basins_attractors_curves(
	fractions_curves, attractors_info, a2rs, prange; add_legend = false
)

ax1, ax2 = content.((fig[2,1], fig[3,1]))

ax1.ylabel = "min(A₁)"
ax2.ylabel = "log(len(A))"

fig</code></pre><img alt="Example block output" src="14db47c8.png"/><h2 id="Enhancing-the-continuation"><a class="docs-heading-anchor" href="#Enhancing-the-continuation">Enhancing the continuation</a><a id="Enhancing-the-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Enhancing-the-continuation" title="Permalink"></a></h2><p>The biggest strength of Attractors.jl is that it is not an isolated software. It is part of <strong>DynamicalSystems.jl</strong>. Here, we will use the full power of <strong>DynamicalSystems.jl</strong> and enrich the above continuation with various other measures of nonlocal stability, in particular Lyapunov exponents and the minimal fatal shock.</p><p>First, let's estimate the maximum Lyapunov exponent (MLE) for all attractors, using the <code>lyapunovspectrum</code> function that comes from the ChaosTools.jl submodule.</p><pre><code class="language-julia hljs">using ChaosTools: lyapunov

lis = map(enumerate(prange)) do (i, p) # loop over parameters
    set_parameter!(ds, pidx, p) # important! We use the dynamical system!
    attractors = attractors_info[i]
    Dict(k =&gt; lyapunov(ds, 2000.0; u0 = A[1]) for (k, A) in attractors)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">66-element Vector{Dict{Int64, Float64}}:
 Dict(1 =&gt; 0.0010161299709218153)
 Dict(1 =&gt; -0.00018191522285785692)
 Dict(1 =&gt; 0.0005779622052021758)
 Dict(1 =&gt; 0.0003258711120489957)
 Dict(1 =&gt; 0.0006442723155681626)
 Dict(1 =&gt; 0.0003228735164650374)
 Dict(1 =&gt; 0.0005456784114706515)
 Dict(1 =&gt; 0.001020866781934005)
 Dict(1 =&gt; 0.0005763119485661954)
 Dict(1 =&gt; 0.0010401502305299858)
 ⋮
 Dict(2 =&gt; 0.0004284257220509743, 3 =&gt; 0.006206560110945673)
 Dict(2 =&gt; 0.0012953050253825264, 3 =&gt; 0.0007418072200930788)
 Dict(2 =&gt; 0.000794699335123927, 3 =&gt; 0.0014665808296540125)
 Dict(2 =&gt; 0.0005158265660794907, 3 =&gt; 0.0009488567968864405)
 Dict(2 =&gt; 0.0010946645321471859)
 Dict(2 =&gt; 0.0015954328672161424)
 Dict(2 =&gt; 5.080893870225528e-5)
 Dict(2 =&gt; 5.172611531752124e-6)
 Dict(2 =&gt; 0.00018994390622102453)</code></pre><p>The above <code>map</code> loop may be intimidating if you are a beginner, but it is really just a shorter way to write a <code>for</code> loop for our example. We iterate over all parameters, and for each we first update the dynamical system with the correct parameter, and then extract the MLE for each attractor. <code>map</code> just means that we don't have to pre-allocate a new vector before the loop; it creates it for us.</p><p>We can visualize the LE with the other convenience function <a href="@ref"><code>plot_continuation_curves!</code></a>,</p><pre><code class="language-julia hljs">ax3 = Axis(fig[4, 1]; ylabel = "MLE")
plot_continuation_curves!(ax3, lis, prange; add_legend = false)

fig</code></pre><img alt="Example block output" src="9ab8f86c.png"/><p>This reveals crucial information for tha attractors, whether they are chaotic or not, that we would otherwise obtain only by visualizing the system dynamics at every single parameter. The story we can see now is that the dynamics start with a limit cycle (0 Lyapunov exponent), go into bi-stability of chaos and limit cycle, then there is only one limit cycle again, and then a chaotic attractor appears again, for a second bistable regime.</p><p>The last piece of information to add is yet another measure of nonlocal stability: the minimal fatal shock (MFS), which is provided by <a href="../api/#Attractors.minimal_fatal_shock"><code>minimal_fatal_shock</code></a>. The code to estimate this is similar with the <code>map</code> block for the MLE. Here however we re-use the created <code>mapper</code>, but now we must not forget to reset it inbetween parameter increments:</p><pre><code class="language-julia hljs">using LinearAlgebra: norm
search_area = collect(extrema.(grid ./ 2)) # smaller search = faster results
search_algorithm = MFSBlackBoxOptim(max_steps = 1000, guess = ones(3))

mfss = map(enumerate(prange)) do (i, p)
    set_parameter!(ds, pidx, p)
    reset_mapper!(mapper) # reset so that we don't have to re-initialize
    # We need a special clause here: if there is only 1 attractor,
    # then there is no MFS. It is undefined. We set it to `NaN`,
    # which conveniently, will result to nothing being plotted by Makie.
    attractors = attractors_info[i]
    if length(attractors) == 1
        return Dict(k =&gt; NaN for (k, A) in attractors)
    end
    # otherwise, compute the actual MFS from the first point of each attractor
    Dict(k =&gt;
        norm(minimal_fatal_shock(mapper, A[1], search_area, search_algorithm))
        for (k, A) in attractors
    )
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">66-element Vector{Dict{Int64, Float64}}:
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 Dict(1 =&gt; NaN)
 ⋮
 Dict(2 =&gt; 0.09602077690021128, 3 =&gt; 0.4895567164464757)
 Dict(2 =&gt; 0.21264304683151156, 3 =&gt; 0.4447680064533198)
 Dict(2 =&gt; 0.6231815789428797, 3 =&gt; 0.34045258142050755)
 Dict(2 =&gt; 0.7554372542027041, 3 =&gt; 0.22436691690732796)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)
 Dict(2 =&gt; NaN)</code></pre><p>In a real application we wouldn't use the first point of each attractor, as the first point is completely random on the attractor (at least, for the [<code>AttractorsViaRecurrences</code>] mapper we use here). We would do this by examining the whole <code>A</code> object in the above block instead of just using <code>A[1]</code>. But this is a tutorial so we don't care!</p><p>Right, so now we can visualize the MFS with the rest of the other quantities:</p><pre><code class="language-julia hljs">ax4 = Axis(fig[5, 1]; ylabel = "MFS", xlabel = "parameter")
plot_continuation_curves!(ax4, mfss, prange; add_legend = false)

# make the figure prettier
for ax in (ax1, ax2, ax3); hidexdecorations!(ax; grid = false); end
resize!(fig, 500, 600)
fig</code></pre><img alt="Example block output" src="7a1f8dd9.png"/><p>And that's the end of the tutorial! See the <a href="@ref examples">examples</a> for more runnable code, and see the <a href="../api/#API">API</a> for a list of all functions and algorithms!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Attractors.jl</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 28 June 2024 07:34">Friday 28 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>